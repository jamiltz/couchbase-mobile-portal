<?xml version="1.0" encoding="UTF-8"?>
<article xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../docs.xsd" id="document">
    <title>Document</title>
    <description>This guide shows you how to use a Document. A Document represents a single database record or row, in the form of a JSON object.</description>
    <introduction>
        <paragraph>In a <emphasis>document database</emphasis> such as Couchbase Lite, the primary entity stored in a database is called a <strong>document</strong> instead of a "row" or "record". This reflects the fact that a document can store more data, with more structure, than its equivalent in other databases.</paragraph>
        <paragraph>In Couchbase Lite (as in Couchbase Server and CouchDB) a document's <strong>body</strong> takes the form of a JSON object â€” a collection of key/value pairs where the values can be different types of data such as numbers, strings, arrays or even nested objects. Every document is identified by a <strong>document ID</strong>, which can be automatically generated (as a UUID) or determined by the application; the only constraints are that it must be unique within the database, and it can't be changed.</paragraph>
        <paragraph>In addition, a document can contain <strong><ref href="attachment.xml">attachments</ref></strong>, named binary blobs that are useful for storing large media files or other non-textual data. Couchbase Lite supports attachments of unlimited size, although the Sync Gateway currently imposes a 10MB limit for attachments synced to it.</paragraph>
        <paragraph>Couchbase Lite keeps track of the change history of every document, as a series of <strong><ref href="revision.xml">revisions</ref></strong>. This is somewhat like a version control system such as Git or Subversion, although its main purpose is not to be able to access old data, but rather to assist the replicator in deciding what data to sync and what documents have conflicts. Every time a document is created or updated, it is assigned a new unique <strong>revision ID</strong>. The IDs of past revisions are available, and the contents of past revisions <emphasis>may</emphasis> be available, but only if the revision was created locally and the database has not yet been compacted.</paragraph>
        <paragraph>To summarize, a document has the following attributes:</paragraph>
        <unordered-list>
            <list-item>A document ID</list-item>
            <list-item>A current revision ID (which changes every time the document is updated)</list-item>
            <list-item>A history of past revision IDs (usually linear, but will form a branching tree if the document has or has had conflicts)</list-item>
            <list-item>A body in the form of a JSON object, i.e. a set of key/value pairs</list-item>
            <list-item>Zero or more named binary attachments</list-item>
        </unordered-list>
    </introduction>
    
    
    <topics>
        <topic id="crud">
            <title>Creating, Reading, Updating and Deleting documents (CRUD)</title>
            <body>
                <paragraph>Couchbase Lite of course supports the typical database "CRUD" operations on documents: Create, Read, Update, Delete.</paragraph>
                
                
                <section id="creating">
                    <title>Creating documents</title>
                    <body>
                        <paragraph>You can create a document with or without giving it an ID. If you don't need or want to define your own ID, call the <ref href="database.xml">Database</ref> method <code>createDocument</code>, and the ID will be generated randomly in the form of a Universally Unique ID (UUID), which looks like a string of hex digits. The uniqueness ensures that there is no chance of an accidental collision by two client apps independently creating different documents with the same ID, then replicating to the same server.</paragraph>
                        <paragraph>The following example shows how to create a document with an automatically-assigned UUID:</paragraph>
                        <code-set>
                            <code-block language="objective-c"><![CDATA[
                                NSString* owner = [@"profile:" stringByAppendingString: userId];
                                NSDictionary* properties = @{@"type":       @"list",
                                                             @"title":      title,
                                                             @"created_at": currentTimeString,
                                                             @"owner":      owner,
                                                             @"members":    @[]};
                                CBLDocument* document = [database createDocument];
                                NSError* error;
                                if (![document putProperties: properties error: &error]) {
                                    [self handleError: error];
                                }
                            ]]></code-block>
                            <code-block language="swift"><![CDATA[
                                let owner = "profile".stringByAppendingString(userId)
                                let properties = [
                                    "type": "list",
                                    "title": title,
                                    "owner": owner,
                                    "memebers": []
                                ]

                                let document = database.createDocument()
                                var error: NSError?
                                if document.putProperties(properties, error: &error) == nil {
                                    self.handleError(error)
                                }
                            ]]></code-block>
                            <code-block language="java"><![CDATA[
                        Map<String, Object> properties = new HashMap<String, Object>();
                        properties.put("type", "list");
                        properties.put("title", title);
                        properties.put("created_at", currentTimeString);
                        properties.put("owner", "profile:" + userId);
                        properties.put("members", new
                        ArrayList<String>());
                        Document document = database.createDocument();
                        document.putProperties(properties); 
							]]></code-block>
                            <code-block language="C#"><![CDATA[
                                var document = database.CreateDocument();
                                var properties = new Dictionary<string, object>()
                                    {
                                        {"type", "list"},
                                        {"title", "title"},
                                        {"created_at", DateTime.UtcNow.ToString ("o")},
                                        {"owner", "profile:" + userId},
                                        {"members", new List<string>()}
                                    };
                                var rev = document.PutProperties(properties);
                                Debug.Assert(rev != null);
                            ]]></code-block>                            
                        </code-set>
                        <paragraph>If you do want to choose the document's ID, just call the Database method <code>getDocument</code>, just as you would to retrieve an existing document. If the document doesn't exist yet, you still get a valid Document object, it just doesn't have any revisions or contents yet. The first time you save the document, it will be added persistently to the database. If a document does already exist with the same ID, saving the document will produce a conflict error.</paragraph>
                        <paragraph>The following example shows how to create a document with an custom ID:</paragraph>
                        <code-set>
                            <code-block language="objective-c"><![CDATA[
                        NSDictionary* properties = @{@"title":      @"Little, Big",
                                                     @"author":     @"John Crowley",
                                                     @"published":  1982};
                        CBLDocument* document = [database documentWithID: @"978-0061120053"];
                        NSError* error;
                        if (![document putProperties: properties error: &error]) {
                            [self handleError: error];
                        }
                            ]]></code-block>
                            <code-block language="swift"><![CDATA[
                                let properties =
                                [
                                    "title": "Little, Big",
                                    "author": "John Crowley",
                                    "published":  1982
                                ]

                                let document = database.documentWithID("978-0061120053")
                                var error: NSError?
                                if document.putProperties(properties, error: &error) == nil {
                                    self.handleError(error)
                                }
                            ]]></code-block>
                            <code-block language="java"><![CDATA[
                                Map<String, Object> properties = new HashMap<String, Object>();
                                properties.put("title", "Little, Big");
                                properties.put("author", "John Crowley");
                                properties.put("published", 1982);
                                Document document = database.getDocument("978-0061120053");
                                try {
                                    document.putProperties(properties);
                                } catch (CouchbaseLiteException e) {
                                    Log.e(TAG, "Cannot save document", e);
                                }
                            ]]></code-block>
                            <code-block language="C#"><![CDATA[
                                var properties = new Dictionary<string, object>
                                    {
                                        {"title", "Little, Big"},
                                        {"author", "John Crowley"},
                                        {"published", 1982}
                                    };
                                var document = database.GetDocument("978-0061120053");
                                Debug.Assert(document != null);

                                var rev = document.PutProperties(properties);
                                Debug.Assert(rev != null);
                            ]]></code-block>                            
                        </code-set>
                        <note type="tip">It's up to you whether to assign your own IDs or use random UUIDs. If the documents are representing entities that already have unique IDs â€” like email addresses or employee numbers â€” then it makes sense to use those, especially if you need to ensure that there can't be two documents representing the same entity. For example, in a library cataloging app, you wouldn't want two librarians to independently create duplicate records for the same book, so you might use the book's ISBN as the document ID to enforce uniqueness.</note>
                    </body>
                </section>
                
                
                <section id="reading">
                    <title>Reading documents</title>
                    <body>
                        <paragraph>To retrieve a Document object given its ID, call the Database method <code>getDocument</code>. As described in the previous section, if there is no document with this ID, this method will return a valid but empty Document object. (If you would rather get a null/nil result for a nonexistent document, call <code>existingDocumentWithID</code> instead.)</paragraph>
                        <paragraph>Document objects, like document IDs, are unique. That means that there is never more than one Document object in memory that represents the same document. If you call <code>getDocument</code> multiple times with the same ID, you get the same Document object every time. This helps conserve memory, and it also makes it easy to compare Document object references (pointers) â€” you can just use <code>==</code> to check whether two references refer to the same document.</paragraph>
                        <paragraph>Loading a Document object doesn't immediately read its properties from the database. Those are loaded on demand, when you call an accessor method like <code>getProperties</code> (or access the Objective-C property <code>properties</code>). The properties are represented using whatever platform type is appropriate for a JSON object. In Objective-C they're an <code>NSDictionary</code>, in Java a <code>Map&lt;String,Object&gt;</code>.</paragraph>
                        <paragraph>Here's a simple example of getting a document's properties:</paragraph>
                        <code-set>
                            <code-block language="objective-c"><![CDATA[
                                CBLDocument* doc = [database documentWithID: _myDocID];
                                // We can directly access properties from the document object:
                                NSString* title = doc[@"title"];
                                // Or go through its properties dictionary:
                                NSDictionary* properties = doc.properties;
                                NSString* owner = properties[@"owner"];
                            ]]></code-block>
                            <code-block language="swift"><![CDATA[
                                let doc = database.documentWithID(myDocID)
                                // We can directly access properties from the document object:
                                let title = doc["title"] as? String
                                // Or go through its properties dictionary:
                                let properties = doc.properties;
                                let owner = properties["owner"] as? String;
                            ]]></code-block>
                            <code-block language="java"><![CDATA[
                                Document doc = database.getDocument(myDocId);
                                // We can directly access properties from the document object:
                                doc.getProperty("title");
                                // Or go through its properties dictionary:
                                Map<String, Object> properties = doc.getProperties();
                                String owner = (String) properties.get("owner");
                            ]]></code-block>
                            <code-block language="C#"><![CDATA[
                                var doc = database.GetDocument(myDocId);
                                // We can directly access properties from the document object:
                                doc.GetProperty("title");
                                // Or go through its properties dictionary:
                                var owner = doc.Properties["owner"];
                            ]]></code-block>
                        </code-set>
                        <note>The <code>getProperties</code> method is actually just a convenient shortcut for getting the Document's <code>currentRevision</code> and then getting <emphasis>its</emphasis> <code>properties</code> â€” since a document usually has multiple <ref href="revision.xml">revisions</ref>, the properties really belong to a revision. Every existing document has a current revision (in fact that's how you can tell whether a document exists or not.) Almost all the time you'll be accessing a document's current revision, which is why the convenient direct properties accessor exists.</note>
                    </body>
                </section>
                
                
                <section id="updating">
                    <title>Updating documents</title>
                    <body>
                        <paragraph>There are two methods that update a document: <code>putProperties</code> and <code>update</code>. We'll cover them both, then explain why they're different.</paragraph>
                        <paragraph><code>putProperties</code> is simpler: given a new JSON object, it replaces the document's body with that object. Actually what it does is creates a new <ref href="revision.xml">revision</ref> with those properties and makes it the document's current revision.</paragraph>
                        <code-set>
                            <code-block language="objective-c"><![CDATA[
                                CBLDocument* doc = [database documentWithID: _myDocID];
                                NSMutableDictionary* p = [doc.properties mutableCopy];
                                p[@"title"] = title;
                                p[@"notes"] = notes;
                                NSError* error;
                                if (![doc putProperties: p error: &error]) {
                                    [self handleError: error];
                                }
                            ]]></code-block>
                            <code-block language="swift"><![CDATA[
                                let doc = database.documentWithID(myDocID)
                                var properties = doc.properties
                                properties["title"] = title
                                properties["notes"] = notes
                                var error: NSError?
                                if doc.putProperties(properties, error: &error) == nil {
                                    self.handleError(error)
                                }
                            ]]></code-block>
                            <code-block language="java"><![CDATA[
                                Document doc = database.getDocument(myDocID);
                                Map<String, Object> properties = new HashMap<String, Object>();
                                properties.putAll(doc.getProperties());
                                properties.put("title", title);
                                properties.put("notes", notes);
                                try {
                                    doc.putProperties(properties);
                                } catch (CouchbaseLiteException e) {
                                    e.printStackTrace();
                                }
                            ]]></code-block>
                            <code-block language="C#"><![CDATA[
                                var doc = database.GetDocument(myDocId);
                                var p = new Dictionary<string, object>(doc.Properties)
                                    {
                                        {"title", title},
                                        {"notes", notes}
                                    };
                                var rev = doc.PutProperties(p);
                                Debug.Assert(rev != null);
                            ]]></code-block>
                        </code-set>
                        <note>Multiple updates using <code>putProperties</code> within a single transaction are currently not supported. For more information, see <external-ref href="https://github.com/couchbase/couchbase-lite-ios/issues/256">issue #256</external-ref> and <external-ref href="https://github.com/couchbase/couchbase-lite-android/issues/220">issue #220</external-ref>.</note>
                        
                        <paragraph><code>update</code> instead takes a callback function or block (the details vary by language). It loads the current revision's properties, then calls this function, passing it an <code>UnsavedRevision</code> object, whose properties are a <emphasis>mutable</emphasis> copy of the current ones. Your callback code can modify this object's properties as it sees fit; after it returns, the modified revision is saved and becomes the current one.</paragraph>
                        <code-set>
                            <code-block language="objective-c"><![CDATA[
                                CBLDocument* doc = [database documentWithID: _myDocID];
                                NSError* error;
                                if (![doc update: ^BOOL(CBLUnsavedRevision *newRev) {
                                    newRev[@"title"] = title;
                                    newRev[@"notes"] = notes;
                                    return YES;
                                } error: &error]) {
                                    [self handleError: error];
                                }
                            ]]></code-block>
                            <code-block language="swift"><![CDATA[
                                let doc = database.documentWithID(myDocID)
                                var error: NSError?
                                doc.update({ (newRev) -> Bool in
                                    newRev["titie"] = title
                                    newRev["notes"] = notes
                                    return true
                                }, error: &error)

                                if error != nil {
                                    self.handleError(error)
                                }
                            ]]></code-block>
                            <code-block language="java"><![CDATA[
                                Document doc = database.getDocument(myDocId);
                                doc.update(new Document.DocumentUpdater() {
                                    @Override
                                    public boolean update(UnsavedRevision newRevision) {
                                        Map<String, Object> properties = newRevision.getUserProperties();
                                        properties.put("title", title);
                                        properties.put("notes", notes);
                                        newRevision.setUserProperties(properties);
                                        return true;
                                    }
                                });
                            ]]></code-block>
                            <code-block language="C#"><![CDATA[
                                var doc = database.GetDocument(myDocId);
                                doc.Update((UnsavedRevision newRevision) => 
                                {
                                    var properties = newRevision.Properties;
                                    properties["title"] = title;
                                    properties["notes"] = notes;
                                    return true;
                                });
                            ]]></code-block>
                        </code-set>
                        <paragraph>Whichever way you save changes, you need to consider the possibility of <strong>update conflicts</strong>. Couchbase Lite uses Multiversion Concurrency Control (MVCC) to guard against simultaneous changes to a document. (Even if your app code is single-threaded, the replicator runs on a background thread and can be pulling <ref href="revision.xml">revisions</ref> into the database at the same time you're making changes.) Here's the typical sequence of events that creates an update conflict:</paragraph>
                        <ordered-list>
                            <list-item>Your code reads the document's current properties, and constructs a modified copy to save</list-item>
                            <list-item>Another thread (perhaps the replicator) updates the document, creating a new revision with different properties</list-item>
                            <list-item>Your code updates the document with its modified properties</list-item>
                        </ordered-list>
                        <paragraph>Clearly, if your update were allowed to proceed, the change from step 2 would be overwritten and lost. Instead, the update will fail with a conflict error. Here's where the two API calls differ:</paragraph>
                        <ordered-list>
                            <list-item><code>putProperties</code> simply returns the error to you to handle. You'll need to detect this type of error, and probably handle it by re-reading the new properties and making the change to those, then trying again.</list-item>
                            <list-item><code>update</code> is smarter: it handles the conflict error itself by re-reading the document, then <emphasis>calling your block again</emphasis> with the updated properties, and retrying the save. It will keep retrying until there is no conflict.</list-item>
                        </ordered-list>
                        <note type="tip">Of the two techniques, calling <code>update</code> may be a bit harder to understand initially, but it actually makes your code simpler and more reliable. We recommend it. (Just be aware that your callback block can be called multiple times.)</note>      
                    </body>
                </section>
                
                
                <section id="deleting">
                    <title>Deleting documents</title>
                    <body>
                        <paragraph>The <code>delete</code> method (<code>deleteDocument:</code> in Objective-C) deletes a document:</paragraph>
                        <code-set>
                            <code-block language="objective-c"><![CDATA[
                                CBLDocument* doc = [database documentWithID: _myDocID];
                                NSError* error;
                                if (![doc deleteDocument: &error]) {
                                    [self handleError: error];
                                }
                            ]]></code-block>
                            <code-block language="swift"><![CDATA[
                                let doc = database.documentWithID(myDocID)
                                var error: NSError?
                                if !doc.deleteDocument(&error) {
                                    self.handleError(error)
                                }
                            ]]></code-block>
                            <code-block language="java"><![CDATA[
                                Document task = (Document) database.getDocument("task1");
                                task.delete(); 
							]]></code-block>
                            <code-block language="C#"><![CDATA[
                                var doc = database.GetDocument(myDocId);
                                doc.Delete();
                            ]]></code-block>
                        </code-set>
                        <paragraph>Deleting a document actually just creates a new <ref href="revision.xml">revision</ref>
                        (informally called a "tombstone") that has the special
                        <code>_deleted</code> property set to <code>true</code>. This ensures that
                        the deletion will replicate to the server, and then to other endpoints that
                        pull from that database, just like any other document revision.</paragraph>
                        <note>It's possible for the <code>delete</code> call to fail with a conflict error, since it's really just a special type of <code>putProperties</code>. In other words, something else may have updated the document at the same time you were trying to delete it. It's up to your app whether it's appropriate to retry the delete operation.</note>
                        <paragraph>If you need to preserve one or more fields in a document that
                        you want to delete (like a record of who deleted it or when it was deleted)
                        you can avoid the <code>delete</code> method; just update the document and
                        set the <code>UnsavedRevision</code>'s <code>deletion</code> property to
                        <code>true</code>, or set JSON properties that include a
                        <code>"_deleted"</code> property with a value of <code>true</code>. You
                        can retain all of the fields, as shown in the following example, or you can
                        remove specified fields so that the tombstone revision contains only the
                        fields that you need.</paragraph>
                        <code-set>
                            <code-block language="objective-c"><![CDATA[
                              CBLDocument* doc = [database documentWithID: _myDocID];
                              NSError* error;
                              if (![doc update: ^BOOL(CBLUnsavedRevision *newRev) {
                                  newRev.isDeletion = YES;  // marks this as a 'tombstone'
                                  newRev[@"deleted_at"] = currentTimeString;
                              } error: &error]) {
                                  [self handleError: error];
                              }
                          ]]></code-block>
                          <code-block language="swift"><![CDATA[
                                doc.update({ (newRev) -> Bool in
                                    newRev.isDeletion = true
                                    newRev["deleted_at"] = currentTimeString
                                    return true
                                }, error: &error)

                                if error != nil {
                                    self.handleError(error)
                                }
                          ]]></code-block>
                          <code-block language="java"><![CDATA[
                                Document doc = database.getDocument(myDocId);
                                doc.update(new Document.DocumentUpdater() {
                                    @Override
                                    public boolean update(UnsavedRevision newRevision) {
                                        newRevision.setIsDeletion(true);
                                        Map<String, Object> properties = newRevision.getUserProperties();
                                        properties.put("deleted_at", currentTimeString);
                                        newRevision.setUserProperties(properties);
                                        return true;
                                    }
                                })
                          ]]></code-block>
                          <code-block language="C#"><![CDATA[
                                var doc = database.GetDocument(myDocId);
                                doc.Update((UnsavedRevision newRevision) => 
                                {
                                    newRevision.IsDeletion = true;
                                    newRevision.Properties["deleted_at"] = currentTimeString;
                                    return true;
                                });
                          ]]></code-block>
                        </code-set>
                    </body>
                </section>
            </body>
        </topic>


        <topic id="notifications">
            <title>Document change notifications</title>
            <body>
                <paragraph>You can register for notifications when a particular document is updated or deleted. This is very useful if you're display a user interface element whose content is based on the document: use the notification to trigger a redisplay of the view.</paragraph>
                <paragraph>You can use change events for the following purposes:</paragraph>
                <unordered-list>
                    <list-item>To be notified when new revisions are added to a
								document</list-item>
                    <list-item>To be notified when a document is deleted</list-item>
                    <list-item>To be notified when a document enters into a conflicted
								state</list-item>
                </unordered-list>
                <code-set>
                    <code-block language="objective-c"><![CDATA[
                      [[NSNotificationCenter defaultCenter] addObserverForName: kCBLDocumentChangeNotification
                                  object: myDocument
                                   queue: nil
                              usingBlock: ^(NSNotification *n) {
                                  CBLDatabaseChange* change = n.userInfo[@"change"];
                                  NSLog(@"There is a new revision, %@", change.revisionID);
                                  [self setNeedsDisplay: YES];  // redraw the view
                              }
                      ];
                      ]]></code-block>
                    <code-block language="swift"><![CDATA[
                        NSNotificationCenter.defaultCenter().addObserverForName(kCBLDocumentChangeNotification, object: myDocument, queue: nil) { 
                            (notification) -> Void in
                                if let change = notification.userInfo!["change"] as? CBLDatabaseChange {
                                    NSLog("This is a new revision, %@", change.revisionID);
                                    set.setNeedsDisplay(true)
                                }
                        }
                      ]]></code-block>
                    <code-block language="java"><![CDATA[
                     Document doc = database.createDocument();
                     doc.addChangeListener(new Document.ChangeListener() { 
                         @Override 
                         public void changed(Document.ChangeEvent event) { 
                             DocumentChange docChange = event.getChange();
                             String msg = "New revision added: %s. Conflict: %s"; 
                             msg = String.format(msg,
                             docChange.getAddedRevision(), docChange.isConflict()); 
                             Log.d(TAG, msg);
                             documentChanged.countDown();
                         } 
                     }); 
                     doc.createRevision().save();
                    ]]></code-block>
                    <code-block language="C#"><![CDATA[
                        var doc = database.CreateDocument();
                        doc.Change += (sender, e) =>
                        {
                            var change = e.Change;
                            var documentId = change.DocumentId;
                            var revisionId = change.RevisionId;
                            var isConflict = change.IsConflict;
                            var addedRev = change.AddedRevision;
                        };
                    ]]></code-block>
                </code-set>
            </body>
        </topic>
      
        <topic id="ttl">
          <title>Document expiration (TTL)</title>
          <body>
            <paragraph>Documents in a local database can have an expiration time. After that time, they 
              are automatically purged from the database - this completely removes them, freeing the space 
              they occupied.</paragraph>
            <paragraph>The following example sets the TTL for a document to 5 seconds from the current time.</paragraph>
            <code-set>
              <code-block language="objective-c"><![CDATA[
NSDate* ttl = [NSDate dateWithTimeIntervalSinceNow: 5];
NSDictionary* properties = @{@"foo": @"bar"};
CBLDocument* doc = [db createDocument];
[doc putProperties:properties error:nil];
doc.expirationDate = ttl;
              ]]>
              </code-block>
              <code-block language="swift"><![CDATA[
var ttl = NSDate(timeIntervalSinceNow: 5)
var properties = ["foo": "bar"]
var doc = db.createDocument()
doc.putProperties(properties, error: nil)
doc.expirationDate = ttl
              ]]>
              </code-block>
              <code-block language="android"><![CDATA[
Date ttl = new Date(new Date() + 5000);
Document doc = database.createDocument();
Map<String, Object> properties = new HashMap<String, Object>();
properties.put("foo", "bar");
doc.putProperties(properties);
doc.setExpirationDate(ttl);
              ]]>
              </code-block>
              <code-block language="java"><![CDATA[
Date ttl = new Date(new Date() + 5000);
Document doc = database.createDocument();
Map<String, Object> properties = new HashMap<String, Object>();
properties.put("foo", "bar");
doc.putProperties(properties);
doc.setExpirationDate(ttl);
              ]]>
              </code-block>
              <code-block language="c#"><![CDATA[
var doc = db.CreateDocument();
doc.PutProperties(new Dictionary<string, object> { { "foo", "bar" } });
doc.ExpireAfter(TimeSpan.FromSeconds(5));
              ]]>
              </code-block>
            </code-set>
            <paragraph>Expiration timing is not highly precise. The times are stored with one-second
              granularity, and the timer that triggers expiration may be delayed slightly by the operating
              system or by other activity on the database thread. Expiration won't happen while the app is not running;
              this means it may be triggered soon after the app is activated or launched, to catch up with expiration
              times that have already passed.</paragraph>
            <note>As with the existing explicit <strong>purge</strong> mechanism, this applies only to the local
              database; it has nothing to do with replication. This expiration time is not propagated when the
              document is replicated. The purge of the document does not cause it to be deleted on any other
              database. If the document is later updated on a remote database that the local database pulls from,
              the new revision will be pulled and the document will reappear.</note>
          </body>
        </topic>
                    
        <topic id="Understanding Conflicts">
            <title>Conflicts</title>
            <body>
                <paragraph>So far we've been talking about a conflict as an error that occurs when you try to update a document that's been updated since you read it. In this scenario, Couchbase Lite is able to stop the conflict before it happens, giving your code a chance to re-read the document and incorporate the other changes.</paragraph>
                <paragraph>However, there's no practical way to prevent a conflict when the two updates are made on different instances of the database. Neither app even knows that the other one has changed the document, until later on when replication propagates their incompatible changes to each other. A typical scenario is:</paragraph>
                <ordered-list>
                    <list-item>Molly creates DocumentA; the revision is 1-5ac</list-item>
                    <list-item>DocumentA is synced to Naomi's device; the latest revision is still
						1-5ac</list-item>
                    <list-item>Molly updates DocumentA, creating revision 2-54a</list-item>
                    <list-item>Naomi makes a different change to DocumentA, creating revision
                    2-877</list-item>
                    <list-item>Revision 2-877 is synced to Molly's device, which already has 2-54a,
						putting the document in conflict</list-item>
                    <list-item>Revision 2-54a is synced to Naomi's device, which already has 2-877,
                    similarly putting the local document in conflict</list-item>
                </ordered-list>
                <paragraph>At this point, even though DocumentA is in a conflicted state, it needs
                to have a current revision. That is, when your app calls
                <code>getProperties</code>, Couchbase Lite has to return
                <emphasis>something</emphasis>. It chooses one of the two conflicting revisions
                (2-877 and 2-54a) as the "winner". The choice is deterministic, which means that
                every device that is faced with the same conflict will pick the same winner,
                without having to communicate. In this case it just compares the revision IDs
                "2-54a" and "2-877" and picks the higher one, "2-877".</paragraph>
                <paragraph>To be precise, Couchbase Lite uses the following rules to handle conflicts: </paragraph>
                <unordered-list>
                    <list-item>The winner is the undeleted leaf revision on the longest revision branch (i.e. with the largest prefix number in its revision ID.)</list-item>
                    <list-item>If there are no undeleted leaf revisions, the deletion (tombstone) on the longest branch wins.</list-item>
                    <list-item>If there's a tie, the winner is the one whose revision ID sorts higher in a simple ASCII comparison.</list-item>
                </unordered-list>
                
                <note>Couchbase Lite does not automatically merge the contents of conflicts.
                Automated merging sometimes works, but in many cases it'll give wrong results; only
                you know your document schemas well enough to decide how conflicts should be
                merged. </note>
                
                <paragraph>In some cases this simple "one revision wins" rule is good enough. For
                example, in a grocery list if two people rename the same item, one of them will
                just see that their change got overwritten, and may do it over again. But usually
                the details of the document content are more important, so the application will
                want to detect and resolve conflicts.</paragraph>
                <note>Resolving conflicts can also save the space in the database. Conflicting
                revisions stay in the database indefinitely until resolved, even surviving
                compactions. Therefore, it makes sense to deal with the conflict by at least
                deleting the non-winning revision. </note>
                <paragraph> Another reason to resolve conflicts is to implement business rules. For
                example, if two sales associates update the same customer record and it ends up in
                conflict, you might want the sales manager to resolve the conflict and "hand merge"
                the two conflicting records so that no information is lost. </paragraph>
                <paragraph>There are two alternative ways to resolve a conflict:</paragraph>
                <unordered-list>
                    <list-item><strong>Pick a winner.</strong> Just decide which of the two changes
                    should win, and delete the other one. The deleted revision will no longer be
                    eligible as a conflict winner, so there won't be any more conflict.</list-item>
                    <list-item><strong>Merge.</strong> Consider the contents of both conflicting
                    revisions and construct a new revision that incorporates both. The details are,
                    of course, application-dependent, and might even require user interaction. Then
                    resolve the conflict by saving the merged revision, then deleting the old
                    losing conflict revision.</list-item>
                </unordered-list>
                <paragraph>The following example shows how to resolve a conflict:</paragraph>
                <code-set>
                    <code-block language="java"><![CDATA[ 
                        final Document doc = database.getDocument(myDocID);
                        final List<SavedRevision> conflicts = doc.getConflictingRevisions();
                        if (conflicts.size() > 1) {
                            // There is more than one current revision, thus a conflict!
                            database.runInTransaction(new TransactionalTask() {
                                @Override
                                public boolean run() {
                                    try {
                                        // Come up with a merged/resolved document in some way that's
                                        // appropriate for the app. You could even just pick the body of
                                        // one of the revisions.
                                        Map<String, Object> mergedProps = mergeRevisions(conflicts);

                                        // Delete the conflicting revisions to get rid of the conflict:
                                        SavedRevision current = doc.getCurrentRevision();
                                        for (SavedRevision rev : conflicts) {
                                            UnsavedRevision newRev = rev.createRevision();
                                            if (rev.getId().equals(current.getId())) {
                                                newRev.setProperties(mergedProps);
                                            } else {
                                                newRev.setIsDeletion(true);
                                            }
                                            // saveAllowingConflict allows 'rev' to be updated even if it
                                            // is not the document's current revision.
                                            newRev.save(true);
                                        }
                                    } catch (CouchbaseLiteException e) {
                                        return false;
                                    }
                                    return true;
                                }
                            });
                        }
					]]></code-block>
                    <code-block language="objective-c"><![CDATA[
                        CBLDocument* doc = [database documentWithID: _myDocID];
                        NSError* error;
                        NSArray* conflicts = [doc getConflictingRevisions: &error];
                        if (conflicts.count > 1) {
                            // There is more than one current revision, thus a conflict!
                            [database inTransaction: ^BOOL{
                                // Come up with a merged/resolved document in some way that's
                                // appropriate for the app. You could even just pick the body of
                                // one of the revisions.
                                NSDictionary* mergedProps = [self mergeRevisions: conflicts];
                            
                                // Delete the conflicting revisions to get rid of the conflict:
                                CBLSavedRevision* current = doc.currentRevision;
                                for (CBLSavedRevision* rev in conflicts) {
                                    CBLUnsavedRevision *newRev = [rev createRevision];
                                    if (rev == current) {
                                        // add the merged revision
                                        newRev.properties = [NSMutableDictionary dictionaryWithDictionary: mergedProps]; 
                                    } else {
                                        // mark other conflicts as deleted
                                        newRev.isDeletion = YES;  
                                    }
                                    // saveAllowingConflict allows 'rev' to be updated even if it
                                    // is not the document's current revision.
                                    NSError *error;
                                    if (![newRev saveAllowingConflict: &error])
                                        return NO;
                                }
                                return YES;
                            }];
                        }
                    ]]></code-block>
                    <code-block language="swift"><![CDATA[
                        let doc = database.documentWithID(myDocID)
                        var error: NSError?
                        if let conflicts = doc.getConflictingRevisions(&error) as? [CBLSavedRevision]{
                            if conflicts.count > 1 {
                                // There is more than one leaf revision, thus a conflict!
                                database.inTransaction({ () -> Bool in
                                    // Come up with a merged/resolved document in some way that's
                                    // appropriate for the app. You could even just pick the body of
                                    // one of the revisions.
                                    var mergedProps = self.mergeRevisions(conflicts)

                                    // Delete the conflicting revisions to get rid of the conflict:
                                    var current = doc.currentRevision
                                    for rev in conflicts {
                                        var newRev = rev.createRevision()
                                        if rev == current {
                                            // add the merged revision
                                            newRev.properties = NSMutableDictionary(dictionary: mergedProps)
                                        } else {
                                            // mark other conflicts as deleted
                                            newRev.isDeletion = true
                                        }

                                        // saveAllowingConflict allows 'rev' to be updated even if it
                                        // is not the document's current revision.
                                        var error: NSError?
                                        if newRev.saveAllowingConflict(&error) == nil {
                                            return false
                                        }
                                    }
                                    return true
                                })
                            }
                        }
                    ]]></code-block>
                    <code-block language="C#"><![CDATA[
                        var doc = database.GetDocument(myDocId);
                        var conflicts = doc.ConflictingRevisions.ToList();
                        if (conflicts.Count > 1)
                        {
                            // There is more than one current revision, thus a conflict!
                            database.RunInTransaction(() => 
                            {
                                var mergedProps = MergeRevisions(conflicts);
                                var current = doc.CurrentRevision;
                                foreach(var rev in conflicts)
                                {
                                    var newRev = rev.CreateRevision();
                                    if (rev == current)
                                    {
                                        newRev.SetProperties(mergedProps);
                                    }
                                    else
                                    {
                                        newRev.IsDeletion = true;
                                    }
                                    // saveAllowingConflict allows 'rev' to be updated even if it
                                    // is not the document's current revision.
                                    newRev.SaveAllowingConflict();
                                }
                                return true;
                            });
                        }
                    ]]></code-block>
                </code-set>
                <section id="conflict-faq">
                    <title>Document Conflict FAQ</title>
                    <body>
                        <description-list>
                            <entry>
                                <title><emphasis>What if both devices make the same change to the document? Is that a conflict?</emphasis></title>
                                <description>No. The revision ID is derived from a digest of the document body. So if two databases save identical changes, they end up with identical revision IDs, and Couchbase Lite (and the Sync Gateway) treat these as the same revision.</description>
                            </entry>
                            <entry>
                                <title><emphasis>I deleted a document, but the it's still in the database, only now its properties are different. What happened?</emphasis></title>
                                <description>Sounds like the document was in conflict and you didn't realize it. You deleted the winning revision, but that made the other (losing) revision become the current one. If you delete the document again, it'll actually go away.</description>
                            </entry>
                            <entry>
                                <title><emphasis>How can I get the properties of the common ancestor revision, to do a three-way merge?</emphasis></title>
                                <description>You can't always. Couchbase Lite isn't a version-control system and doesn't preserve old revision bodies indefinitely. But if the ancestor revision used to exist in your local database, and you haven't yet compacted the database, you can still get its properties. Get the <code>parentRevision</code> property of the current revision to get the ancestor, then see if its <code>properties</code> are still non-null.</description>
                            </entry>
                            <entry>
                                <title><emphasis>How can I tell if a document has a conflict?</emphasis></title>
                                <description>Call its <code>getConflictingRevisions</code> method and see if more than one revision is returned.</description>
                            </entry>
                            <entry>
                                <title><emphasis>How can I tell if there are any conflicts in the database?</emphasis></title>
                                <description>Use an <ref href="query.xml#all-docs">all-documents query</ref> with the <code>onlyConflicts</code> mode.</description>
                            </entry>
                        </description-list>
                    </body>
                </section>
            </body>
        </topic>
        <topic id="purging-a-document">
            <title>Purging documents</title>
            <body>
                <paragraph>Purging a document is different from deleting it; it's more like <emphasis>forgetting</emphasis> it. The <code>purge</code> method removes all trace of a document (and all its revisions and their attachments) from the <emphasis>local</emphasis> database. It has no effect on replication or on remote databases, though.</paragraph>
                <paragraph>Purging is mostly a way to save disk space by forgetting about replicated documents that you don't need anymore. It has some slightly weird interactions with replication, though. For example, if you purge a document, and then later the document is updated on the remote server, the next replication will pull the document into your database again.</paragraph>
            </body>
        </topic>

        <topic id="special-properies">
            <title>Special Properties</title>
            <body>
                <paragraph>The body of a document contains a few special properties that store metadata about the document. For the most part you can ignore these since the API provides accessor methods for the same information, but it can still be helpful to know what they are if you encounter them.</paragraph>
                <unordered-list>
                    <list-item><code>_id</code>: The document ID.</list-item>
                    <list-item><code>_rev</code>: The revision ID.</list-item>
                    <list-item><code>_attachments</code>: Metadata about the document's attachments.</list-item>
                    <list-item><code>_deleted</code>: Only appears in a deletion (tombstone) revision, where it has the value <code>true</code>.</list-item>
                </unordered-list>
                <note type="note">A leading underscore always denotes a reserved propertyâ€”donâ€™t
					use an underscore prefix for any of your own properties, and don't change the value of any reserved property. </note>
            </body>
        </topic>
    </topics>
</article>
