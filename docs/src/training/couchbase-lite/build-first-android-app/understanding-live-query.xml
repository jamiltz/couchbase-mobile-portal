<?xml version="1.0" encoding="UTF-8"?>
<lesson xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="../../../docs.xsd" id="">
    <title>Understanding a LiveQuery</title>
    <description></description>
    <introduction>
        <paragraph>
            To help us track the changes that could be occurring in such a mobile development environment, the CBL has an implementation of the Observer pattern known as a LiveQuery. We will use the LiveQuery to go deeper into the possibilities of how listening for changes can help us provide solutions.
        </paragraph>
    </introduction>

    <tasks>
        <task id="introduction">
            <title>Introduction</title>
            <body>
                <paragraph>
                    A.	We have the concept of a “live query” which is encapsulated by the class: com.couchbase.lite.LiveQuery.
                    B.	The meaning of a  LiveQuery is that it is a type of Observer [GoF] on the Query object. The Observer pattern sets up a relationship between two objects whereby the Observer (or listener) is notified of some event by the object it is observing. The listener must register with the object to which it is listening, using some method, so that the object knows who is registered and listening. Then the listener is “notified” of changes by having a method invoked by the object to which it is listening.
                    C.	We get a LiveQuery from the Query factory method toLiveQuery().
                    D.	Because the LiveQuery came from the Query itself, it is already set to Observe the Query data. That is, the Query contains data from the View. We are going to listen (observe) that data, using a ChangeListener.
                    E.	We have to perform the following steps to accomplish this, and then we can be notified per the Observer pattern of any changes to the data underlying the Query we are Observing:
                    1.	Invoke the LiveQuery addChangeListener(…) method and pass as a parameter a new ChangeListener. This registers our listener.
                    2.	This ChangeListener should override the method changed(…)
                    3.	Start the LiveQuery so it is listening for changes to the data bounded by the Query.
                    F.	Let’s take a look at the code for this now:
                </paragraph>

                <code-block language="java"><![CDATA[
                        LiveQuery myLiveQuyery = eventsByDateView.createQuery().toLiveQuery();
                    myLiveQuery.addChangeListener(

                    /* instantiate the ChangeListener right here */

                    	new LiveQuery.ChangeListener() {

                    		@Override /* A notification listener method */
                    		public void changed(ChangeEvent changeEvent) {

                    			Log.i(“couchbaseevents”,
                    "Data changed in the Query…");
                    }
                    }
                    );
                ]]>
                </code-block>

                <paragraph>
                    A.	Let’s understand this listener code, and its deeper ramifications.
                    1.	First we got our LiveQuery from the factory.
                    2.	Next we add a ChangeListener to the LiveQuery, so we can do something, whenever data in our Query changes.
                    3.	We have to instantiate one, and override the appropriate method: changed()
                    4.	Within the method we write to the log file. Naturally you could do whatever you want in this method.
                </paragraph>
            </body>
        </task>

        <task id="the-change-event">
            <title>The Change Event</title>
            <body>
                <paragraph>
                    A.	Let’s understand more about the incoming ChangeEvent, and what it means that the changed() method was invoked, and given a reference to this event by the CBL API.
                    1.	The LiveQuery is listening for changes to Document versions.
                    2.	Let’s say that DocumentA is part of the Query.
                    3.	When the revision of DocumentA is saved after an update, there is a new version of DocumentA, and that new version being available for read causes the ChangeEvent to be instantiated and passed over to the changed(…) ,method.
                    a.	This means that every version of the document causes a new ChangeEvent to come over.
                    b.	This means that if DocumentA had one data element updated (changed), such as “address,” it was cause a ChangeEvent to be fired.
                    c.	This also means that if DocumentA had three data elements  change, such as “address,” “date” and “description” still only one ChangeEvent would be fired off, because the LiveQuery only listens at the Document version level, not at the data attribute level within the document.
                    d.	Furthermore, we receive the ChangeEvent but no details about what within the document was changed.
                    e.	In order to figure out what exactly has changed, we would need to run a new Query, and compare the results to that of the previous query. More likely, some UI element value has entirely changed.
                    f.	Therefore we say, the LiveQuery notifies the ChangeListener THAT data in the Query has been updated, not HOW that data has been updated.
                    g.	To recap, the ChangeListener changed(…) method is invoked each time any document in the Query has a version change (updated version), and passed a ChangeEvent.
                    h.	The ChangeEvent itself has access to the original Query data (before any change occurred) via the getRows() method which provides a QueryEnumerator over that original data, like this:
                </paragraph>

                <code-block language="java"><![CDATA[
public void changed (ChangeEvent changeEvent) {

QueryEnumerator originalData = changeEvent.getRows();

/* work with Query data */
}
                ]]>
                </code-block>
            </body>
        </task>


    </tasks>
</lesson>
