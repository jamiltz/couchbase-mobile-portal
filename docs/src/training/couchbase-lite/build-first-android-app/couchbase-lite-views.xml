<?xml version="1.0" encoding="UTF-8"?>
<lesson xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="../../../docs.xsd" id="couchbase-lite-views">
    <title>Working with Couchbase Views</title>
    <description>Create, retrieve, update, and delete documents in the HelloWorld database</description>
    <introduction>
        <paragraph>
            In Couchbase Server we have the notion of a View (or Index) created from a subset of Document data. CBL also allows for View creation, however the View API is significantly different, and the resulting views are also stored differently. Let’s find out how we can create and leverage views in CBL.
        </paragraph>
    </introduction>

    <tasks>

        <task id="intro">
            <title>
                Introduction
            </title>
            <body>
                <paragraph>
                    A.	A View created in Couchbase Lite is NOT maintained as a View in the Couchbase Server at all (see: http://developer.couchbase.com/mobile/develop/guides/couchbase-lite/native-api/view/index.html)
                    1.	In Couchbase Lite, the View only exists on the mobile device.
                    2.	A View is not a Query. There is a separate CBL Query API as we will soon understand.
                    B.	We will use a com.couchbase.lite.View for our work here.
                    C.	There is a factory method on the Database called getView(“name”) for creating this object. We must provide the database a unique name for each view. Let’s encapsulate this work now for our application development:
                </paragraph>

                <code-block language="java"><![CDATA[
                    private View getView(String name) {

                    View view = null;
                    	try {

                    		view = this.getDatabaseInstance().getView(name);

                    	}
                    	catch (CouchbaseLiteException cble) {
                    		cble.printStackTrace();
                    	}
                    	return view;
                    }
                ]]>
                </code-block>
            </body>
        </task>

        <task id="creating-view">
            <title>
                Creating a view
            </title>
            <body>
                <paragraph>
                    A.	We simply pass the parameter name to the factory method and return the freshly created View.
                    B.	Now that we have this method, we can write a specialized method-per-View for each View we wish to create.
                    C.	For example if we want to create a specialized view for eventsByDate we would write this method:
                </paragraph>

                <code-block language="java"><![CDATA[
                    public void createEventsByDateView() {

                    View eventsByDateView =  this.getView("eventsByDate");

                    	eventsByDateView.setMap(

                    		new Mapper(){

                    			@Override
                    			public void map(Map<String, Object> document,
                    Emitter emitter) {

                    				/* Emit data to matieralized view */
                    				emitter.emit(
                    (String) document.get("date"), null);
                    			}

                    		},
                    		"1" /* The version number of the mapper... */

                    );/* end setMap(…) invocation whew! */

                    	/* Test it out... */
                    	printQueryToLog(eventsByDateView);
                    }
                ]]>
                </code-block>

                <paragraph>
                    A.	Let’s discuss this method, first we leverage our private getView(…) method we just wrote to fetch a fresh View from the Database, with the name “eventsByDate.”
                    B.	Now we have to set the map function on the view, using setMap(…)
                    1.	We do this dynamically with a new Mapper object passed in anonymously on the fly.
                    2.	This works because of the @Override of the map(…) method, where all the action is.
                    3.	We also provide a version number “1” of the map code.
                    C.	The map method provides the references to the document we wish to index, and the emitter which will emit that data to the index.
                    D.	We are only interested in the Event date at this point, so we emit that date and null.
                </paragraph>
            </body>
        </task>

        <task id="running-query">
            <title>Running a Query</title>
            <body>
                <paragraph>
                    A.	Lastly we test our work in the printQueryToLog(…) method. Let’s take a look at that code now:
                </paragraph>

                <code-block language="java"><![CDATA[
                    private void printQueryToLog(View view) {

                    // Get instance of Query from factory…
                    Query orderedQuery = view.createQuery();

                    orderedQuery.setDescending(true);
                    orderedQuery.setStartKey("2015");
                    orderedQuery.setEndKey("2014");
                    orderedQuery.setLimit(20);

                    try {
                    QueryEnumerator results = orderedQuery.run();

                    	/* Iterate through the rows to get the document ids */
                    	for (Iterator<QueryRow> it = results; it.hasNext();) {

                    		QueryRow row = it.next();

                    		String docId = (String) row.getValue();

                    	Event event = eventRepository.getById(docId);
                    		Log.i(CBLSingleton.TAG, "Found party:" + event);

                    }

                    } catch (CouchbaseLiteException e) {
                    Log.e(CBLSingleton.TAG, "Error querying view.", e);
                    }

                    }
                ]]>
                </code-block>

                <paragraph>
                    A.	Let’s take a closer look now at this method to print the results of our Query to the log.
                    1.	First we need a Query object which we can get from the View’s factory method. See documentation here: http://developer.couchbase.com/mobile/develop/guides/couchbase-lite/native-api/query/index.html
                    2.	We want the most-future events first, and the oldest most-past events last, so we modify our Query setDescending(true).
                    3.	We don’t intend to look further in the future than 2015, and we don’t care about events prior to 2014, so we set start and end keys.
                    4.	We only want the first 20 results, so we set the limit to 20, which is the maximum number of documents to return.
                    5.	After a Query object is set up properly, you call its run method to get the results.
                    i.	The results are returned as a QueryEnumerator object, which mainly serves as an enumerable collection of QueryRow objects.
                    6.	We then iterate over the results getting each QueryRow.
                    7.	For each QueryRow in the results, we find the docId and use an EventRepository to fetch the actual complete Event object from the Sync Gateway.
                </paragraph>
            </body>
        </task>

    </tasks>
</lesson>
