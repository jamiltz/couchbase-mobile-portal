<?xml version="1.0" encoding="UTF-8"?>
<lesson xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="../../../docs.xsd" id="couchbase-lite-views">
    <title>Working with Couchbase Views</title>
    <description>Introducing Views through code</description>
    <introduction>
        <paragraph>
            In Couchbase Server we have the notion of a View (or Index) created from a subset of Document data. Couchbase Lite also allows for View creation, however the View API is significantly different, and the resulting views are also stored differently. Let us find out how we can create and leverage views in Couchbase Lite.
        </paragraph>
    </introduction>

    <tasks>

        <task id="intro">
            <title>
                Introduction
            </title>
            <body>
                <paragraph>
                    Creating a View in Couchbase Lite is not maintained as a View in the Couchbase Server.  In Couchbase Lite, the View only exists on the mobile device.  We will use a <code>Couchbase.Lite.View</code> for our work here.
                </paragraph>
                <paragraph>    
                    There is a factory method on the Database called <code>GetView(“name”)</code> for creating this object. We must provide the database a unique name for each view. Let us encapsulate this work now for our application development:
                </paragraph>

                <code-block language="csharp"><![CDATA[
                    Couchbase.Lite.View GetView (string name)
                    {
                        Couchbase.Lite.View view = null;
                        try {
                            view = db.GetView (name);
                        } catch (CouchbaseLiteException e) {
                            Console.WriteLine (e.StackTrace);
                            Log.Error (TAG, "Cannot get view", e.StackTrace);
                        }
                        return view;
                    }
                ]]>
                </code-block>
            </body>
        </task>

        <task id="creating-view">
            <title>
                Creating a view
            </title>
            <body>
                <paragraph>
                    To create a View we simply pass the parameter name to the factory method and return the freshly created View.
                    Now that we have this method, we can write a specialized method-per-View for each View we wish to create.
                    For example, if we want to create a specialized view for <code>eventsByDate</code> we would write the method:
                </paragraph>

                <code-block language="csharp"><![CDATA[
                    public void CreateEventsByDateView() {
                        var eventsByDateView = GetView("eventsByDate");
                        eventsByDateView.SetMap ((doc, emit) => 
                            emit ((string)doc ["date"], null), "1");

                        PrintQueryToLog (eventsByDateView);
                    }
                ]]>
                </code-block>

                <paragraph>
                    Within the <code>eventsByDateView</code> method above, we first leverage our private <code>GetView</code> method that we just wrote before to fetch a fresh View from the Database with name 'eventsByDate' passed in.  
                </paragraph>
                <paragraph>
                Then we set the map function on the view, using <code>SetMap</code>. We pass <code>SetMap</code> a lambda expression that references the documents we wish to index and the emitter that will emit the data to the index.
                </paragraph>
                <paragraph>
                We are only interested in the Event date at this point, so we emit that date and null while providing a version number "1" of the map code.  We test out the code by executing <code>PrintQueryToLog</code>, passing the 'eventsByDateView' variable.
                </paragraph>
            </body>
        </task>

        <task id="running-query">
            <title>Running a Query</title>
            <body>
                <paragraph>
                    The above code called the <code>PrintQuertyToLog</code> method. Let’s take a look at that code now:
                </paragraph>

                <code-block language="csharp"><![CDATA[
                    async void PrintQueryToLog (Couchbase.Lite.View view)
                    {
                        var orderedQuery = view.CreateQuery ();
                        orderedQuery.Descending = true;
                        orderedQuery.StartKey = "2015";
                        orderedQuery.EndKey = "2014";
                        orderedQuery.Limit = 20;

                        try {
                            var results = await orderedQuery.RunAsync ();

                            results.ToList ().ForEach (result => {
                                var evt = eventRepository.GetById (result.DocumentId);
                                Log.Info (TAG, "Found party: " + evt);

                            });
                        } catch (CouchbaseLiteException e) {
                            Log.Error (TAG, "Error querying view", e);
                        }
                    }
                ]]>
                </code-block>

                <paragraph>
                    Let us take a closer look now at this method to print the results of our Query to the log.
                    First we need a Query object which we can get from the View’s factory method. See documentation here:
                    <external-ref href="http://developer.couchbase.com/mobile/develop/guides/couchbase-lite/native-api/query/index.html">Query API Refererence
                    </external-ref>
                </paragraph>
                <paragraph>
                    We want the most-future events first, and the oldest most-past events last, so we set <code>orderedQuery.Descending = true</code>.  We do not intend to look further in the future than 2015, and we do not care about events prior to 2014, so we set start and end keys accordingly.
                </paragraph>
                <paragraph>    
                    We only want the first 20 results, so we set the limit to 20, which is the maximum number of documents to return.
                    After a Query object is set up properly, you call its run method to get the results.
                </paragraph>
                <paragraph>
                    The results are returned as a QueryEnumerator object, which mainly serves as an enumerable collection of QueryRow objects.  We then iterate over the results getting each QueryRow.
                    For each QueryRow in the results, we find the 'docId' and use an EventRepository to fetch the actual complete Event object from the Sync Gateway.
                </paragraph>
            </body>
        </task>

    </tasks>
</lesson>
